/** * @author Osiel Hernández (@OssprO) */package com.maths{	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.geom.Matrix;	import flash.geom.Point;
		/**	 * Clase con funciones estáticas para realización de operaciones geometricas simples	 */		public class OPGeometrica{				/**		* Calcula la distancia entre dos puntos		*/		public static function distancia(punto_a:Point,punto_b:Point):Number{			var _distancia:Number = new Number();			_distancia = Math.sqrt(Math.pow(punto_b.x-punto_a.x,2)+Math.pow(punto_b.y-punto_a.y,2));			return _distancia;		}		/**		* Calcula el punto medio entre dos puntos		*/		public static function puntomedio(punto_a:Point,punto_b:Point):Point{			var _puntomedio:Point = new Point();			_puntomedio.x = (punto_a.x - punto_b.x) / 2;			_puntomedio.y = (punto_a.y - punto_b.y) / 2;			return _puntomedio;		}		/**		* Calcula la pendiente de una recta, daos por dos puntos		*/		public static function pendiente(punto_a:Point,punto_b:Point):Number{			var _pendiente:Number = new Number();			_pendiente = (punto_b.y - punto_a.y) / (punto_b.x - punto_a.x);			return _pendiente;		}		/**		* Calcula la pendiente del angulo de una recta		*/		public static function pendienteangulo(angulo:Number):Number{			var _pendienteangulo:Number = new Number();			_pendienteangulo = Math.tan(angulo);			return _pendienteangulo;		}		/**		 * Calcula el angulo de inclinación de una recta dada su pendiente.		 *		 * @param pendiente		El valor de la pendiente a calcular		 * 		 * @return 				El valor del angulo en base a la pendiente dada		*/		public static function angulo(pendiente:Number):Number{ 			var _angulo:Number = new Number();			_angulo = Math.atan(pendiente);			return _angulo;		}		/**		* Calcula el angulo entre dos rectas dadas sus pendientes		*/		public static function angulorectas(pend_a:Number,pend_b:Number):Number{			var _angulorectas:Number = new Number();			_angulorectas = Math.atan((pend_b-pend_a)/(1+pend_a*pend_b));			return _angulorectas;		}		/**		* Convierte un valor dado en radianes a grados		*/		public static function toDregree(radianes:Number):Number{			var _grados:Number = new Number();			_grados = radianes * 180 / Math.PI;			return _grados;		}		/**		* Convierte un valor dado en grados a radianes		*/		public static function toRadians(grados:Number):Number{			var _radianes:Number = new Number();			_radianes = grados * Math.PI / 180;			return _radianes;		}		/**		* Calcula la atura de un Triangulo Equilatero dado su lado		*/		public static function htrianguloeq(lado:Number):Number{			var _altura:Number = new Number();			_altura = lado*(Math.sqrt(3)/2);			return _altura;		}		/**		* Determina los puntos de interseccion entre dos circunferencias dadas sus coordenadas de origen y radios		*/		public static function puntosintersec(pcirc1:Point,pcirc2:Point,radcirc1:Number,radcirc2:Number):Array{			var presult:Array = new Array();			var distancia:Number = new Number();			distancia = Point.distance(pcirc1,pcirc2);			if(distancia > (radcirc1 + radcirc2) || distancia < (Math.abs(radcirc1-radcirc2))){				//Los circulos no se intersectan				presult = null;			}else{				var base: Number = new Number();				base = ((Math.pow(radcirc1,2))-(Math.pow(radcirc2,2))+(Math.pow(distancia,2)))/(2*distancia);				var altura:Number = new Number();				altura = Math.sqrt((Math.pow(radcirc1,2)-Math.pow(base,2)));								var xmedia:Number = new Number();				xmedia = pcirc1.x + base * (pcirc2.x - pcirc1.x) / distancia;				var ymedia:Number = new Number();				ymedia = pcirc1.y + base * (pcirc2.y - pcirc1.y) / distancia;								var pintsct1:Point = new Point();				var pintsct2:Point = new Point();								pintsct1.x = xmedia + altura * (pcirc2.y - pcirc1.y) / distancia;				pintsct1.y = ymedia - altura * (pcirc2.x - pcirc1.x) / distancia;				pintsct2.x = xmedia - altura * (pcirc2.y - pcirc1.y) / distancia;				pintsct2.y = ymedia + altura * (pcirc2.x - pcirc1.x) / distancia;								presult[0] = pintsct1;				presult[1] = pintsct2;			}			return presult;		}		/**		* Determina los puntos de interseccion entre dos lineas, dados el punto de origen y punto final de cada linea		*/		public static function interseccion2Lineas(p_a_luno:Point,p_b_luno:Point,p_a_ldos:Point,p_b_ldos:Point):Point{			var _interseccionlineas:Point = new Point();			var xa:Number = p_b_luno.x-p_a_luno.x;			var ya:Number = p_b_luno.y-p_a_luno.y;			var xb:Number = p_b_ldos.x-p_a_luno.y;			var yb:Number = p_b_ldos.y-p_a_ldos.y;			var d:Number = yb*xa - xb*ya;			var ua:Number = (xb*(p_a_luno.y-p_a_ldos.y) - yb*(p_a_luno.x-p_a_luno.y))/d;			if (ua >= 0 && ua <=1) {				var ub:Number = (xa*(p_a_luno.y-p_a_ldos.y) - ya*(p_a_luno.x-p_a_luno.y))/d;				if (ub >= 0 && ub <= 1) {					_interseccionlineas.x = p_a_luno.y+xb*ub;					_interseccionlineas.y = p_a_ldos.y+yb*ub;					return _interseccionlineas;				} else {					return null;				}			} else {			return null;			}		}				public static function centerRotation(objeto:DisplayObjectContainer, angulo:Number):void{			//retrieve transform matrix			var matriz:Matrix = objeto.transform.matrix;			var p:Point = new Point(objeto.x + objeto.width/2, objeto.y + objeto.height/2);			//translacion inicial			matriz.tx -= p.x;			matriz.ty -= p.y;			//aplicamos rotacion			matriz.rotate(angulo*(Math.PI/180));			//translacion a su sitio original			matriz.tx += p.x;			matriz.ty += p.y;			//aplicamos matriz de transformacion			objeto.transform.matrix = matriz;		}			}// final class	} // final package